<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MongoDB .NET Driver</title>
    <link>/mongo-csharp-driver/2.0/</link>
    <description>Recent content on MongoDB .NET Driver</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Mar 2015 16:56:14 +0000</lastBuildDate>
    <atom:link href="/mongo-csharp-driver/2.0/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Issues &amp; Help</title>
      <link>/mongo-csharp-driver/2.0/issues_help/</link>
      <pubDate>Wed, 18 Mar 2015 16:56:14 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/issues_help/</guid>
      <description>

&lt;h2 id=&#34;questions:5994e935a64c55120f0d30dc6628456b&#34;&gt;Questions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://groups.google.com/group/mongodb-user&#34;&gt;Discussion Forum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/tagged/mongodb&#34;&gt;Stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;bug-reports:5994e935a64c55120f0d30dc6628456b&#34;&gt;Bug Reports&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jira.mongodb.org/browse/CSHARP&#34;&gt;JIRA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’ve identified a security vulnerability in a driver or any other MongoDB project, please report it according to the &lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/create-a-vulnerability-report&#34;&gt;instructions here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started</title>
      <link>/mongo-csharp-driver/2.0/getting_started/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/getting_started/</guid>
      <description>

&lt;h2 id=&#34;getting-started:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;This quick-start privides just enough information to get you started using the .NET driver. Refer to the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/&#34;&gt;reference guide&lt;/a&gt; for more complete information.&lt;/p&gt;

&lt;h2 id=&#34;system-requirements:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;System Requirements&lt;/h2&gt;

&lt;p&gt;.NET 4.5 or later is required to utilize the libraries. It has also been tested with Mono 3.10 on OS X.&lt;/p&gt;

&lt;h3 id=&#34;core-clr:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Core CLR&lt;/h3&gt;

&lt;p&gt;As the Core CLR hasn&amp;rsquo;t shipped yet, we don&amp;rsquo;t yet have support for it. We run compatibility reports using the &lt;a href=&#34;https://visualstudiogallery.msdn.microsoft.com/1177943e-cfb7-4822-a8a6-e56c7905292b&#34;&gt;.NET Portability Analyzer&lt;/a&gt; to mitigate the need to make public API changes when we are ready to release compatible assemblies.&lt;/p&gt;

&lt;h2 id=&#34;nuget-installation:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Nuget Installation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.nuget.org/&#34;&gt;Nuget&lt;/a&gt; is the simplest way to get the driver. There are 4 packages available on nuget.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.nuget.org/packages/mongodb.driver&#34;&gt;MongoDB.Driver&lt;/a&gt;: The new driver. It is mostly free of any legacy code and should be used for all new projects. More documentation can be found in the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/driver/&#34;&gt;reference guide&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.nuget.org/packages/mongodb.driver.core&#34;&gt;MongoDB.Driver.Core&lt;/a&gt;: The core of the driver and a dependency of MongoDB.Driver. You will probably not use this package directly. More documentation can be found in the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/driver_core/&#34;&gt;reference guide&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.nuget.org/packages/mongodb.bson&#34;&gt;MongoDB.Bson&lt;/a&gt;: The BSON layer. It is a dependency of MongoDB.Driver.Core. It may be used by itself. More documentation can be found in the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/&#34;&gt;reference guide&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.nuget.org/packages/mongocsharpdriver&#34;&gt;mongocsharpdriver&lt;/a&gt;: The compatibility layer for those upgrading from our 1.x series. This should not be used for new projects. More information can be found in the &lt;a href=&#34;http://mongodb.github.io/mongo-csharp-driver/1.x&#34;&gt;1.x documentation&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;binary-installation:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Binary Installation&lt;/h2&gt;

&lt;p&gt;Alternatively, if you&amp;rsquo;d like to pull down binaries, you can do that from the &lt;a href=&#34;https://github.com/mongodb/mongo-csharp-driver/releases&#34;&gt;releases section&lt;/a&gt; on our &lt;a href=&#34;https://github.com/mongodb/mongo-csharp-driver&#34;&gt;github repository&lt;/a&gt;, which contains zip files for each release.&lt;/p&gt;

&lt;p&gt;The assembly names mostly correlate strongly with the package names above. For new applications, you&amp;rsquo;ll add references to &lt;code&gt;MongoDB.Driver.dll&lt;/code&gt;, &lt;code&gt;MongoDB.Driver.Core.dll&lt;/code&gt;, and &lt;code&gt;MongoDB.Bson.dll&lt;/code&gt;. For those working with legacy applications, you&amp;rsquo;ll also want to add a reference to &lt;code&gt;MongoDB.Driver.Legacy.dll&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Connecting to the Server</title>
      <link>/mongo-csharp-driver/2.0/getting_started/connecting/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/getting_started/connecting/</guid>
      <description>

&lt;h2 id=&#34;connecting:d67a243cdf521fafcb45cf3f560d3e12&#34;&gt;Connecting&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_MongoClient.htm
&#34;&gt;&lt;code&gt;MongoClient&lt;/code&gt;&lt;/a&gt; instance is the root object to handle connecting to the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var client = new MongoClient();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will connect to a mongod or mongos running on localhost port 27017. If you&amp;rsquo;d like to use a remote host, you can provide a &lt;a href=&#34;http://docs.mongodb.org/manual/reference/connection-string/&#34;&gt;connection string&lt;/a&gt; to the constructor or construct a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_MongoClientSettings.htm
&#34;&gt;&lt;code&gt;MongoClientSettings&lt;/code&gt;&lt;/a&gt; object and pass it in. To see more about connecting with a client, see the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/driver/connecting/&#34;&gt;reference guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
There is no connecting or disconnecting. A connection pool is used and connections are managed automatically.
&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;database:d67a243cdf521fafcb45cf3f560d3e12&#34;&gt;Database&lt;/h2&gt;

&lt;p&gt;From here, you&amp;rsquo;ll want to retrieve an &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_IMongoDatabase.htm
&#34;&gt;&lt;code&gt;IMongoDatabase&lt;/code&gt;&lt;/a&gt; instance.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var db = client.GetDatabase(&amp;quot;test&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will retrieve a reference to the database named &amp;ldquo;test&amp;rdquo; in MongoDB. There is no need to create the database before hand. It will get created upon first use. If you use more than one database, call GetDatabase again with a different name.&lt;/p&gt;

&lt;h2 id=&#34;collection:d67a243cdf521fafcb45cf3f560d3e12&#34;&gt;Collection&lt;/h2&gt;

&lt;p&gt;From here, you&amp;rsquo;ll need to retrieve a reference to an &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_IMongoCollection_1.htm
&#34;&gt;&lt;code&gt;IMongoCollection&amp;lt;TDocument&amp;gt;&lt;/code&gt;&lt;/a&gt; instance, where &lt;code&gt;TDocument&lt;/code&gt; is the type of document with which to work. This will be either a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_BsonDocument.htm
&#34;&gt;&lt;code&gt;BsonDocument&lt;/code&gt;&lt;/a&gt; or a custom class of your own. You would use a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_BsonDocument.htm
&#34;&gt;&lt;code&gt;BsonDocument&lt;/code&gt;&lt;/a&gt; when the data you are working with is so free form that it would be difficult or impossible to define domain classes for it or because you want to handle the mapping yourself.&lt;/p&gt;

&lt;p&gt;One constraint on your custom class is that it must contain an &lt;code&gt;Id&lt;/code&gt; field. You can read more about customizing classes in the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/&#34;&gt;reference guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Consider the following class definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Entity
{
    public ObjectId Id { get; set; }

    public string Name { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can get a reference to a collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var collection = db.GetCollection&amp;lt;Entity&amp;gt;(&amp;quot;entities&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, as with database, there is no need to create a collection before it&amp;rsquo;s used. It will get created automatically.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reading and Writing</title>
      <link>/mongo-csharp-driver/2.0/getting_started/reading_and_writing/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/getting_started/reading_and_writing/</guid>
      <description>

&lt;h2 id=&#34;reading-and-writing:1b37fd24c24c59d59a5361df5b8a9d7f&#34;&gt;Reading and Writing&lt;/h2&gt;

&lt;p&gt;This page is a brief overview of performing basic reading and writing operations with the driver. All the operations available in the API are async utilizing &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.threading.tasks.task.aspx&#34;&gt;&lt;code&gt;Tasks&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For more information about interacting with the server, refer to the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/driver/crud/&#34;&gt;reference guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The rest of this document assumes the following class and collection:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Person
{
    public ObjectId Id { get; set; }

    public string Name { get; set; }

    public int Age { get; set; }

    public string Profession { get; set; }
}

var collection = db.GetCollection&amp;lt;Person&amp;gt;(&amp;quot;people&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;inserting-a-document:1b37fd24c24c59d59a5361df5b8a9d7f&#34;&gt;Inserting a document&lt;/h2&gt;

&lt;p&gt;To insert a document, use the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Driver_IMongoCollection_1_InsertOneAsync.htm
&#34;&gt;&lt;code&gt;InsertOneAsync&lt;/code&gt;&lt;/a&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var jane = new Person { Name = &amp;quot;Jane McJane&amp;quot;, Age = 24, Profession = &amp;quot;Hacker&amp;quot; };

await collection.InsertOneAsync(jane);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After insertion, the Jane&amp;rsquo;s &lt;code&gt;Id&lt;/code&gt; property will contain the automatically generated identifier. For more on Id generation, see the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/#id-generators:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;reference guide&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;finding-a-document:1b37fd24c24c59d59a5361df5b8a9d7f&#34;&gt;Finding a Document&lt;/h2&gt;

&lt;p&gt;To find all the people who are younger than 42, use the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Driver_IMongoCollectionExtensions_Find__1_1.htm
&#34;&gt;&lt;code&gt;Find&lt;/code&gt;&lt;/a&gt; method such as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var people = await collection.Find(x =&amp;gt; x.Age &amp;lt; 42).ToListAsync();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The lambda expression gets translated into the BSON filter &lt;code&gt;{ Age: { $lt: 42 } }&lt;/code&gt;. Not everything is supported via expression trees, but most of the common operations are. See the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/driver/definitions/#filters:ce6bd7650aa92e884a2bb6da9703168d&#34;&gt;reference guide&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h2 id=&#34;updating:1b37fd24c24c59d59a5361df5b8a9d7f&#34;&gt;Updating&lt;/h2&gt;

&lt;p&gt;To update a document, there are 2 methods for doing so. First, you can update specific fields. For instance, I&amp;rsquo;d like to change Tom&amp;rsquo;s profession to &amp;ldquo;Musician&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var result = await collection.UpdateOneAsync(
    x =&amp;gt; x.Name == &amp;quot;Tom&amp;quot;,
    Builders&amp;lt;Person&amp;gt;.Update.Set(x =&amp;gt; x.Profession, &amp;quot;Musician&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will generate a filter of &lt;code&gt;{ Name: &amp;quot;Tom&amp;quot; }&lt;/code&gt; and an update specification of &lt;code&gt;{ $set: { Profession: &amp;quot;Musician&amp;quot; } }&lt;/code&gt;. Only one document will get updated even if there is more than one person named &amp;ldquo;Tom&amp;rdquo; because we used &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Driver_IMongoCollection_1_UpdateOneAsync.htm
&#34;&gt;&lt;code&gt;UpdateOneAsync&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Driver_IMongoCollection_1_UpdateManyAsync.htm
&#34;&gt;&lt;code&gt;UpdateManyAsync&lt;/code&gt;&lt;/a&gt;. More information on updates is available in the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/driver/crud/writing/#update-and-replace:a65cffa9c73225e9b2db0699034df561&#34;&gt;reference guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Alternatively, if we want to replace a  document completely, we can use the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Driver_IMongoCollection_1_ReplaceOneAsync.htm
&#34;&gt;&lt;code&gt;ReplaceOneAsync&lt;/code&gt;&lt;/a&gt; method. Assuming Tom&amp;rsquo;s &lt;code&gt;Id&lt;/code&gt; value is &amp;ldquo;550c4aa98e59471bddf68eef&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var tom = await collection.Find(x =&amp;gt; x.Id == ObjectId.Parse(&amp;quot;550c4aa98e59471bddf68eef&amp;quot;)).SingleAsync();
tom.Name = &amp;quot;Thomas&amp;quot;;
tom.Age = 43;
tom.Profession = &amp;quot;Hacker&amp;quot;;
var result = await collection.ReplaceOneAsync(x =&amp;gt; x.Id == tom.Id, tom);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
Identifiers in MongoDB are immutable, so you can&amp;rsquo;t replace a document with another one where the identifier is different.
&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;deleting:1b37fd24c24c59d59a5361df5b8a9d7f&#34;&gt;Deleting&lt;/h2&gt;

&lt;p&gt;Finally, to delete Tom, you would use the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Driver_IMongoCollection_1_DeleteOneAsync.htm
&#34;&gt;&lt;code&gt;DeleteOneAsync&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Driver_IMongoCollection_1_DeleteManyAsync.htm
&#34;&gt;&lt;code&gt;DeleteManyAsync&lt;/code&gt;&lt;/a&gt; methods, such as in the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var result = await collection.DeleteOneAsync(x =&amp;gt; x.Id == tom.Id);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>index</title>
      <link>/mongo-csharp-driver/2.0/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/</guid>
      <description>

&lt;h2 id=&#34;welcome-to-the-net-mongodb-driver-documentation:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Welcome to the .NET MongoDB Driver Documentation&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/getting_started/&#34;&gt;Getting Started&lt;/a&gt; guide contains information about system requirements, installation, and a simple tutorial to get up and running quickly.&lt;/p&gt;

&lt;h2 id=&#34;what-s-new-in-2-0:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;What&amp;rsquo;s new in 2.0&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/what_is_new/&#34;&gt;What&amp;rsquo;s New&lt;/a&gt; contains the major new features of the driver, the most important of which is full async support.&lt;/p&gt;

&lt;h2 id=&#34;upgrading:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Upgrading&lt;/h2&gt;

&lt;p&gt;If you are coming from the 1.x series of the driver, consult the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/upgrading/&#34;&gt;upgrading&lt;/a&gt; documentation on major changes.&lt;/p&gt;

&lt;h2 id=&#34;reference:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Reference&lt;/h2&gt;

&lt;p&gt;If you are looking for more detailed documentation, see the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/&#34;&gt;Reference&lt;/a&gt; guide.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BsonDocument</title>
      <link>/mongo-csharp-driver/2.0/reference/bson/bson_document/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/reference/bson/bson_document/</guid>
      <description>

&lt;h2 id=&#34;bsondocument:5cf4e1eeecb274a768c951aabb9995ca&#34;&gt;BsonDocument&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_BsonDocument.htm
&#34;&gt;&lt;code&gt;BsonDocument&lt;/code&gt;&lt;/a&gt; is the default type used for documents. It handles dynamic documents of any complexity. For instance, the document &lt;code&gt;{ a: 1, b: [{ c: 1 }] }&lt;/code&gt; can be built as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var doc = new BsonDocument
{
    { &amp;quot;a&amp;quot;, 1 },
    { &amp;quot;b&amp;quot;, new BsonArray
           {
                new BsonDocument(&amp;quot;c&amp;quot;, 1)
           }}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition, there is a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_BsonDocument_Parse.htm
&#34;&gt;&lt;code&gt;Parse&lt;/code&gt;&lt;/a&gt; method to make reading a JSON string simple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var doc = BsonDocument.Parse(&amp;quot;{ a: 1, b: [{ c: 1 }] }&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reading and Writing BSON/JSON</title>
      <link>/mongo-csharp-driver/2.0/reference/bson/bson/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/reference/bson/bson/</guid>
      <description>

&lt;h2 id=&#34;reading:9a3f4a06c5e6703b45401d6d4a0f6eef&#34;&gt;Reading&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_IO_IBsonReader.htm
&#34;&gt;&lt;code&gt;IBsonReader&lt;/code&gt;&lt;/a&gt; interface contains all the methods necessary to read a &lt;a href=&#34;http://bsonspec.org&#34;&gt;BSON&lt;/a&gt; document or a &lt;a href=&#34;http://json.org&#34;&gt;JSON&lt;/a&gt; document. There is an implementation for each format.&lt;/p&gt;

&lt;h3 id=&#34;bson:9a3f4a06c5e6703b45401d6d4a0f6eef&#34;&gt;BSON&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_IO_BsonBinaryReader.htm
&#34;&gt;&lt;code&gt;BsonBinaryReader&lt;/code&gt;&lt;/a&gt; is for reading binary BSON. For example, to read a BSON file containing the document &lt;code&gt;{ a: 1 }&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;string inputFileName; // initialize to a file containing BSON

using (var stream = File.OpenRead(inputFileName))
using (var reader = new BsonBinaryReader(stream))
{
    reader.ReadStartDocument();
    string fieldName = reader.ReadName();
    int value = reader.ReadInt32();
    reader.ReadEndDocument();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;json:9a3f4a06c5e6703b45401d6d4a0f6eef&#34;&gt;JSON&lt;/h3&gt;

&lt;p&gt;In the same way, we can read a JSON string using a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_IO_JsonReader.htm
&#34;&gt;&lt;code&gt;JsonReader&lt;/code&gt;&lt;/a&gt;. For example, to read the document &lt;code&gt;{ a: 1 }&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var jsonString = &amp;quot;{ a: 1 }&amp;quot;;
using (var reader = new JsonReader(jsonString))
{
    reader.ReadStartDocument();
    string fieldName = reader.ReadName();
    int value = reader.ReadInt32();
    reader.ReadEndDocument();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_IO_JsonReader.htm
&#34;&gt;&lt;code&gt;JsonReader&lt;/code&gt;&lt;/a&gt; supports reading strict JSON as well as both flavors of &lt;a href=&#34;http://docs.mongodb.org/manual/reference/mongodb-extended-json/
&#34;&gt;MongoDB Extended JSON&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;writing:9a3f4a06c5e6703b45401d6d4a0f6eef&#34;&gt;Writing&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_IO_IBsonWriter.htm
&#34;&gt;&lt;code&gt;IBsonWriter&lt;/code&gt;&lt;/a&gt; interface contains all the methods necessary to write a &lt;a href=&#34;http://bsonspec.org&#34;&gt;BSON&lt;/a&gt; document or a &lt;a href=&#34;http://json.org&#34;&gt;JSON&lt;/a&gt; document. There is an implementation for each format.&lt;/p&gt;

&lt;h3 id=&#34;bson-1:9a3f4a06c5e6703b45401d6d4a0f6eef&#34;&gt;BSON&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_IO_BsonBinaryWriter.htm
&#34;&gt;&lt;code&gt;BsonBinaryWriter&lt;/code&gt;&lt;/a&gt; is for writing binary BSON. For example, to write the document &lt;code&gt;{ a: 1 }&lt;/code&gt; to a BSON file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;string outputFileName; // initialize to the file to write to.

using (var stream = File.OpenWrite(outputFileName))
using (var writer = new BsonBinaryWriter(stream))
{
    writer.WriteStartDocument();
    writer.WriteName(&amp;quot;a&amp;quot;);
    writer.WriteInt32(1);
    writer.WriteEndDocument();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;json-1:9a3f4a06c5e6703b45401d6d4a0f6eef&#34;&gt;JSON&lt;/h3&gt;

&lt;p&gt;In the same way, we can write a JSON string using a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_IO_JsonWriter.htm
&#34;&gt;&lt;code&gt;JsonWriter&lt;/code&gt;&lt;/a&gt;. For example, to write the document &lt;code&gt;{ a: 1 }&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;string outputFileName; // initialize to the file to write to.

using (var output = new StreamWriter(outputFileName))
using (var writer = new JsonWriter(output))
{
    writer.WriteStartDocument();
    writer.WriteName(&amp;quot;a&amp;quot;);
    writer.WriteInt32(1);
    writer.WriteEndDocument();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;settings:9a3f4a06c5e6703b45401d6d4a0f6eef&#34;&gt;Settings&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_IO_JsonWriter.htm
&#34;&gt;&lt;code&gt;JsonWriter&lt;/code&gt;&lt;/a&gt; supports writing strict JSON as well as both flavors of &lt;a href=&#34;http://docs.mongodb.org/manual/reference/mongodb-extended-json/
&#34;&gt;MongoDB Extended JSON&lt;/a&gt;. This, and other things, can be customized with the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_IO_JsonWriterSettings.htm
&#34;&gt;&lt;code&gt;JsonWriterSettings&lt;/code&gt;&lt;/a&gt; class.&lt;/p&gt;

&lt;p&gt;For instance, to write in a format for the &lt;a href=&#34;http://docs.mongodb.org/manual/administration/scripting/&#34;&gt;MongoDB Shell&lt;/a&gt;, you can set the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_IO_JsonWriterSettings_OutputMode.htm
&#34;&gt;&lt;code&gt;OutputMode&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;Shell&lt;/code&gt; and also set the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_IO_JsonWriterSettings_Version.htm
&#34;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; to the desired shell version.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var settings = new JsonWriterSettings
{
    OutputMode = JsonOutputMode.Shell,
    Version = new Version(3.0) // target the syntax of MongoDB 3.0
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>BSON</title>
      <link>/mongo-csharp-driver/2.0/reference/bson/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/reference/bson/</guid>
      <description>

&lt;h2 id=&#34;bson-reference:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;BSON Reference&lt;/h2&gt;

&lt;p&gt;The MongoDB.Bson library handles &lt;a href=&#34;http://bsonspec.org&#34;&gt;BSON&lt;/a&gt; and &lt;a href=&#34;http://json.org&#34;&gt;JSON&lt;/a&gt; as well as serialization to and from .NET types.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/bson/&#34;&gt;Reading and Writing BSON/JSON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/bson_document/&#34;&gt;BsonDocument&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/serialization/&#34;&gt;Serialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/&#34;&gt;Mapping Classes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Conventions</title>
      <link>/mongo-csharp-driver/2.0/reference/bson/mapping/conventions/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/reference/bson/mapping/conventions/</guid>
      <description>

&lt;h2 id=&#34;conventions:de7544cb3809030281cea13d469fab66&#34;&gt;Conventions&lt;/h2&gt;

&lt;p&gt;When &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/#automap:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;automapping&lt;/a&gt; a class, there are a lot of decisions that need to be made. For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Which members of the class should be serialized&lt;/li&gt;
&lt;li&gt;Which member of the class is the “Id”&lt;/li&gt;
&lt;li&gt;What element name should be used in the BSON document&lt;/li&gt;
&lt;li&gt;If the class is being used polymorphically, what discriminator values are used&lt;/li&gt;
&lt;li&gt;What should happen if a BSON document has elements we don’t recognize&lt;/li&gt;
&lt;li&gt;Does the member have a default value&lt;/li&gt;
&lt;li&gt;Should the default value be serialized or ignored&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Answers to these questions are represented by a set of “conventions”. For each convention, there is a default convention that is the most likely one you will be using, but you can override individual conventions as necessary.&lt;/p&gt;

&lt;p&gt;If you want to use your own conventions that differ from the defaults, simply create an instance of &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_ConventionPack.htm
&#34;&gt;&lt;code&gt;ConventionPack&lt;/code&gt;&lt;/a&gt;, add in the conventions you want to use, and then register that pack. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var pack = new ConventionPack();
pack.Add(new CamelCaseElementNameConvention());

ConventionRegistry.Register(
   &amp;quot;My Custom Conventions&amp;quot;,
   pack,
   t =&amp;gt; t.FullName.StartsWith(&amp;quot;MyNamespace.&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third parameter is a filter function that defines when this convention pack should be used. Above, we are saying that any classes whose full names begin with &amp;ldquo;MyNamespace.&amp;rdquo; should use these conventions.&lt;/p&gt;

&lt;h2 id=&#34;custom-conventions:de7544cb3809030281cea13d469fab66&#34;&gt;Custom Conventions&lt;/h2&gt;

&lt;p&gt;In addition to pre-packaged conventions, it is possible to write your own. There are 4 classes of conventions which can be created and registered. These 4 classes of conventions correspond with the 4 stages in which they will be run.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Class Stage:&lt;/strong&gt; &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_IClassMapConvention.htm
&#34;&gt;&lt;code&gt;IClassMapConvention&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Run against the class map.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Member Stage:&lt;/strong&gt; &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_IMemberMapConvention.htm
&#34;&gt;&lt;code&gt;IMemberMapConvention&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Run against each member map discovered during the Class stage.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Creator Stage:&lt;/strong&gt; &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_ICreatorMapConvention.htm
&#34;&gt;&lt;code&gt;ICreatorMapConvention&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Run against each CreatorMap discovered during the Class stage.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Post Processing Stage:&lt;/strong&gt; &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_IPostProcessingConvention.htm
&#34;&gt;&lt;code&gt;IPostProcessingConvention&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Run against the class map.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Conventions get run in the order they were registered in each stage. The default set of conventions is registered first. This allows any user registered conventions to override the values applied by the default conventions. Hence, it is possible that certain values may get applied and overwritten. It is up to the user to ensure that the order is correct.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
&lt;p&gt;If a custom implementation of an &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_IPostProcessingConvention.htm&#34;&gt;&lt;code&gt;IPostProcessingConvention&lt;/code&gt;&lt;/a&gt; is registered before a customer implementation of an &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_IClassMapConvention.htm&#34;&gt;&lt;code&gt;IClassMapConvention&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_IClassMapConvention.htm&#34;&gt;&lt;code&gt;IClassMapConvention&lt;/code&gt;&lt;/a&gt; will be run first because the Class Stage is before the Post Processing Stage.&lt;/p&gt;

&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;example:de7544cb3809030281cea13d469fab66&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;As an example, we will write a custom convention to name all the elements the corresponding lower-case version of the member name. We can implement this convention as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class LowerCaseElementNameConvention : IMemberMapConvention 
{
    public void Apply(BsonMemberMap memberMap) 
    {
        memberMap.SetElementName(memberMap.MemberName.ToLower());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you are doing one-off conventions like this, it might be easier to create them with a simple lambda expresion instead. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var pack = new ConventionPack();
pack.AddMemberMapConvention(
    &amp;quot;LowerCaseElementName&amp;quot;,
    m =&amp;gt; m.SetElementName(m.MemberName.ToLower()));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the best examples of writing custom conventions, it is good to consult the source for the pre-packaged conventions.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mapping Classes</title>
      <link>/mongo-csharp-driver/2.0/reference/bson/mapping/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/reference/bson/mapping/</guid>
      <description>

&lt;h2 id=&#34;mapping-classes:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Mapping Classes&lt;/h2&gt;

&lt;p&gt;Using a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_BsonDocument.htm
&#34;&gt;&lt;code&gt;BsonDocument&lt;/code&gt;&lt;/a&gt; will work when a schema is fluid and dynamic. However, most applications are built with a schema modeled in the application itself rather than the database. In these cases, it is likely that the application uses classes.&lt;/p&gt;

&lt;p&gt;The .NET BSON library supports mapping these classes to and from BSON/JSON using a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_BsonClassMap_1.htm
&#34;&gt;&lt;code&gt;BsonClassMap&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-class-map:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Creating a Class Map&lt;/h2&gt;

&lt;p&gt;In a majority of cases, the driver will be able to automatically map your class for you. This will happen if you begin to use a class for which no &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/serialization/#serializers:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;serializer&lt;/a&gt; has yet been registered in the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/serialization/#serializer-registry:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;serializer registry&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can choose to register the class map using the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_Serialization_BsonClassMap_RegisterClassMap_1.htm
&#34;&gt;&lt;code&gt;RegisterClassMap&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
It is very important that the registration of class maps occur prior to them being needed. The best place to register them is at app startup prior to initializing a connection with MongoDB.
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;If you want to control the creation of the class map, you can provide your own initializatzion code in the form of a lambda expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.MapMember(c =&amp;gt; c.SomeProperty);
    cm.MapMember(c =&amp;gt; c.AnotherProperty);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When your lambda expression is executed, the &lt;code&gt;cm&lt;/code&gt; (short for class map) parameter is passed an empty class map for you to fill in. In this example, two properties are added to the class map by calling the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_Serialization_BsonClassMap_1_MapMember_1.htm
&#34;&gt;&lt;code&gt;MapMember&lt;/code&gt;&lt;/a&gt; method. The arguments to the method are themselves lambda expressions which identify the member of the class. The advantage of using a lambda expression instead of just a string parameter with the name of the property is that Intellisense and compile time checking ensure that you can’t misspell the name of the property.&lt;/p&gt;

&lt;h2 id=&#34;automap:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;AutoMap&lt;/h2&gt;

&lt;p&gt;It is also possible to use automapping and then override some of the results using the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_Serialization_BsonClassMap_1_AutoMap.htm
&#34;&gt;&lt;code&gt;AutoMap&lt;/code&gt;&lt;/a&gt; method. This method should be called first in the lambda expression.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapMember(c =&amp;gt; c.SomeProperty);
    cm.MapMember(c =&amp;gt; c.AnotherProperty);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_Serialization_BsonClassMap_1_AutoMap.htm
&#34;&gt;&lt;code&gt;AutoMap&lt;/code&gt;&lt;/a&gt; uses conventions to map the class and its members. See the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/conventions/&#34;&gt;convention documentation&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h2 id=&#34;class-customization:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Class Customization&lt;/h2&gt;

&lt;p&gt;There are several serialization options that are related to the class itself instead of to any particular field or property. You can set these class level options either by decorating the class with serialization related attributes or by writing initialization code.&lt;/p&gt;

&lt;h3 id=&#34;ignoring-extra-elements:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Ignoring Extra Elements&lt;/h3&gt;

&lt;p&gt;When a BSON document is deserialized, the name of each element is used to look up a matching member in the class map. Normally, if no matching member is found, an exception will be thrown. If you want to ignore extra elements during deserialization, use a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonIgnoreExtraElementsAttribute.htm
&#34;&gt;&lt;code&gt;BsonIgnoreExtraElementsAttribute&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[BsonIgnoreExtraElements]
public MyClass 
{
    // fields and properties
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.SetIgnoreExtraElements(true);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;admonition important&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
When you ignore extra elements, if the class is rendered back to BSON, those extra elements will not exist and may be lost forever.
&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;supporting-extra-elements:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Supporting Extra Elements&lt;/h3&gt;

&lt;p&gt;You can design your class to be capable of handling any extra elements that might be found in a BSON document during deserialization. To do so, you must have a property of type &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_BsonDocument.htm
&#34;&gt;&lt;code&gt;BsonDocument&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/.aspx&#34;&gt;&lt;code&gt;IDictionary&amp;lt;string, object&amp;gt;&lt;/code&gt;&lt;/a&gt;) and you must identify that property as the one that should hold any extra elements that are found. By &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/conventions/&#34;&gt;convention&lt;/a&gt;, the member may be named &amp;ldquo;ExtraElements&amp;rdquo;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public MyClass 
{
    // fields and properties
    [BsonExtraElements]
    public BsonDocument CatchAll { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapExtraElementsMember(c =&amp;gt; c.CatchAll);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a BSON document is deserialized, any extra elements found will be stored in the extra elements property. When the class is serialized, the extra elements will be serialized also. One thing to note though is that the serialized class will probably not have the elements in exactly the same order as the original document. All extra elements will be serialized together when the extra elements member is serialized.&lt;/p&gt;

&lt;h3 id=&#34;discriminators:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Discriminators&lt;/h3&gt;

&lt;p&gt;See the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/polymorphism/&#34;&gt;polymorphism&lt;/a&gt; section for documentation on discriminators and polymorphism.&lt;/p&gt;

&lt;p&gt;To specify a discriminator, use a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonDiscriminatorAttribute.htm
&#34;&gt;&lt;code&gt;BsonDiscriminatorAttribute&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[BsonDiscriminator(&amp;quot;myclass&amp;quot;)]
public MyClass 
{
    // fields and properties
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.SetDiscriminator(&amp;quot;myclass&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;isupportinitialize:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;ISupportInitialize&lt;/h3&gt;

&lt;p&gt;If your class implements &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.componentmodel.isupportinitialize.aspx&#34;&gt;&lt;code&gt;ISupportInitialize&lt;/code&gt;&lt;/a&gt;, the driver will call the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.componentmodel.isupportinitialize.begininit.aspx&#34;&gt;&lt;code&gt;BeginInit&lt;/code&gt;&lt;/a&gt; method before deserialization and the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.componentmodel.isupportinitialize.endinit.aspx&#34;&gt;&lt;code&gt;EndInit&lt;/code&gt;&lt;/a&gt; method upon completion. It is useful for running operations before or after deserialization such as handling schema changes are pre-calculating some expensive operations.&lt;/p&gt;

&lt;h2 id=&#34;creation-customization:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Creation Customization&lt;/h2&gt;

&lt;p&gt;By default, classes must contain a no-argument constructor that will be used to instantiate the class to rehydrate. However, it is possible to configure a constructor whose arguments are correlated with mapped properties or fields. There are a couple of ways to do this.&lt;/p&gt;

&lt;p&gt;Using an expression, you can instruct the driver to use a creator map as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Person
{
    public string FirstName { get; private set; }
    public string LastName { get; private set; }

    public Person(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }
}

// snip...

BsonClassMap.RegisterClassMap&amp;lt;Person&amp;gt;(cm =&amp;gt;
{
    cm.AutoMap();
    cm.MapCreator(p =&amp;gt; new Person(p.FirstName, p.LastName));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parsing the expression tree correlates the first constructor argument with the FirstName property and the second constructor argument with the LastName property. There are other, more complicated ways of handling this which can be explored on your own should the need arise.&lt;/p&gt;

&lt;p&gt;Using attributes instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }

    [BsonConstructor]
    public Person(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, a convention runs on every CreatorMap with no mapped arguments and attempts to correlate the names of the constructor arguments with the names of mapped members. If your names differ in more than just case, there are overloads of BsonConstructor which can be used to explicity tell the driver which members to use.&lt;/p&gt;

&lt;p&gt;When more than one constructor is found, we will use the constructor that has the most matching parameters. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public DateTime? BirthDate { get; set; }

    [BsonConstructor]
    public Person(string firstName, string lastName)
    {
        // snip...
    }

    [BsonConstructor]
    public Person(string firstName, string lastName, DateTime birthDate)
    {
        // snip...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the document in the database has a BirthDate element, we will choose to use the constructor with three parameters because it is more specific.&lt;/p&gt;

&lt;h2 id=&#34;member-customization:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Member Customization&lt;/h2&gt;

&lt;p&gt;You can also control serialization at the individual class or field or property level using code to configure the class and member maps or using attributes to decorate the class and members. For each aspect of serialization you can control, we will be showing both ways.&lt;/p&gt;

&lt;h3 id=&#34;opt-in:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Opt-In&lt;/h3&gt;

&lt;p&gt;A majority of classes will have their members &lt;a href=&#34;#automap:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;mapped automatically&lt;/a&gt;. There are some circumstances where this does not happen. For instance, if your property is read-only, it will not get included in the automapping of a class by default. In order to include the member, you can use the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonElementAttribute.htm
&#34;&gt;&lt;code&gt;BsonElementAttribute&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;class MyClass
{
    private readonly string _someProperty;

    [BsonElement]
    public string SomeProperty
    {
        get { return _someProperty; }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapProperty(c =&amp;gt; c.SomeProperty);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
When a readonly property is serialized, it value is persisted to the database, but never read back out. This is useful for storing “computed” properties.
&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;element-name:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Element Name&lt;/h3&gt;

&lt;p&gt;To specify an element name using attributes, write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass 
{
    [BsonElement(&amp;quot;sp&amp;quot;)]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapMember(c =&amp;gt; c.SomeProperty).SetElementName(&amp;quot;sp&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;element-order:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Element Order&lt;/h3&gt;

&lt;p&gt;If you want precise control over the order of the elements in the BSON document, you can use the Order named parameter to the BsonElement attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass 
{
    [BsonElement(&amp;quot;sp&amp;quot;, Order = 1)]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapMember(c =&amp;gt; c.SomeProperty).SetElementName(&amp;quot;sp&amp;quot;).SetOrder(1);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any fields or properties that do not have an explicit Order will occur after those that do have an Order.&lt;/p&gt;

&lt;h3 id=&#34;the-id-member:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;The Id Member&lt;/h3&gt;

&lt;p&gt;By &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/conventions/&#34;&gt;convention&lt;/a&gt;, a public member called &lt;code&gt;Id&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, or &lt;code&gt;_id&lt;/code&gt; will be used as the identifier. You can be specific about this using the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonIdAttribute.htm
&#34;&gt;&lt;code&gt;BsonIdAttribute&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass 
{
    [BsonId]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapIdMember(c =&amp;gt; c.SomeProperty);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;id-generators:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Id Generators&lt;/h4&gt;

&lt;p&gt;When you Insert a document, the driver checks to see if the &lt;code&gt;Id&lt;/code&gt; member has been assigned a value and, if not, generates a new unique value for it. Since the &lt;code&gt;Id&lt;/code&gt; member can be of any type, the driver requires the help of an &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_IIdGenerator.htm
&#34;&gt;&lt;code&gt;IIdGenerator&lt;/code&gt;&lt;/a&gt; to check whether the &lt;code&gt;Id&lt;/code&gt; has a value assigned to it and to generate a new value if necessary. The driver has the following Id generators built-in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;{{ apiref &amp;quot;T_MongoDB_Bson_Serialization_IdGenerators_ObjectIdGenerator&amp;quot; &amp;gt;}}&#34;&gt;&lt;code&gt;ObjectIdGenerator&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;{{ apiref &amp;quot;T_MongoDB_Bson_Serialization_IdGenerators_StringObjectIdGenerator&amp;quot; &amp;gt;}}&#34;&gt;&lt;code&gt;StringObjectIdGenerator&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;{{ apiref &amp;quot;T_MongoDB_Bson_Serialization_IdGenerators_GuidGenerator&amp;quot; &amp;gt;}}&#34;&gt;&lt;code&gt;GuidGenerator&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;{{ apiref &amp;quot;T_MongoDB_Bson_Serialization_IdGenerators_CombGuidGenerator&amp;quot; &amp;gt;}}&#34;&gt;&lt;code&gt;CombGuidGenerator&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;{{ apiref &amp;quot;T_MongoDB_Bson_Serialization_IdGenerators_NullIdChecker&amp;quot; &amp;gt;}}&#34;&gt;&lt;code&gt;NullIdChecker&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;{{ apiref &amp;quot;T_MongoDB_Bson_Serialization_IdGenerators_ZeroIdChecker_1&amp;quot; &amp;gt;}}&#34;&gt;&lt;code&gt;ZeroIdChecker&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;{{ apiref &amp;quot;T_MongoDB_Bson_Serialization_IdGenerators_BsonObjectIdGenerator&amp;quot; &amp;gt;}}&#34;&gt;&lt;code&gt;BsonObjectIdGenerator&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some of these Id generators are used automatically for commonly used &lt;code&gt;Id&lt;/code&gt; types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;{{ apiref &amp;quot;T_MongoDB_Bson_Serialization_IdGenerators_GuidGenerator&amp;quot; &amp;gt;}}&#34;&gt;&lt;code&gt;GuidGenerator&lt;/code&gt;&lt;/a&gt; is used for a &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.guid.aspx&#34;&gt;&lt;code&gt;Guid&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;{{ apiref &amp;quot;T_MongoDB_Bson_Serialization_IdGenerators_ObjectIdGenerator&amp;quot; &amp;gt;}}&#34;&gt;&lt;code&gt;ObjectIdGenerator&lt;/code&gt;&lt;/a&gt; is used for an &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_ObjectId.htm
&#34;&gt;&lt;code&gt;ObjectId&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;{{ apiref &amp;quot;T_MongoDB_Bson_Serialization_IdGenerators_StringObjectIdGenerator&amp;quot; &amp;gt;}}&#34;&gt;&lt;code&gt;StringObjectIdGenerator&lt;/code&gt;&lt;/a&gt; is used for a &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.string.aspx&#34;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; represented externally as &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_ObjectId.htm
&#34;&gt;&lt;code&gt;ObjectId&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To specify the Id generator via an attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass 
{
    [BsonId(IdGenerator = typeof(CombGuidGenerator))]
    public Guid Id { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapIdMember(c =&amp;gt; c.Id).SetIdGenerator(CombGuidGenerator.Instance);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could also say that you want to use the &lt;a href=&#34;{{ apiref &amp;quot;T_MongoDB_Bson_Serialization_IdGenerators_CombGuidGenerator&amp;quot; &amp;gt;}}&#34;&gt;&lt;code&gt;CombGuidGenerator&lt;/code&gt;&lt;/a&gt; for all Guids.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonSerializer.RegisterIdGenerator(
    typeof(Guid),
    CombGuidGenerator.Instance
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ignoring-a-member:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Ignoring a Member&lt;/h3&gt;

&lt;p&gt;When constructing a class map manually, you can ignore a field or property simply by not adding it to the class map. When using AutoMap, you need a way to specify that a field or property should be ignored. Use the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonIgnoreAttribute.htm
&#34;&gt;&lt;code&gt;BsonIgnoreAttribute&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass 
{
    [BsonIgnore]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.UnmapMember(c =&amp;gt; c.SomeProperty);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using code, &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_Serialization_BsonClassMap_1_AutoMap.htm
&#34;&gt;&lt;code&gt;AutoMap&lt;/code&gt;&lt;/a&gt; will have initially added the property to the class map automatically. &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_Serialization_BsonClassMap_1_UnmapMember_1.htm
&#34;&gt;&lt;code&gt;UnmapMember&lt;/code&gt;&lt;/a&gt; will remove it.&lt;/p&gt;

&lt;h3 id=&#34;ignoring-default-values:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Ignoring Default Values&lt;/h3&gt;

&lt;p&gt;By default, default values are serialized to the BSON document. An alternative is to serialize nothing to the BSON document when the member has a default value. For reference types, this value is &lt;code&gt;null&lt;/code&gt; and for value types, the default is whatever the default is for the value type. Use a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonIgnoreIfDefaultAttribute.htm
&#34;&gt;&lt;code&gt;BsonIgnoreIfDefaultAttribute&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass 
{
    [BsonIgnoreIfDefault]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapMember(c =&amp;gt; c.SomeProperty).SetIgnoreIfDefault(true);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;specifying-the-default-value:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Specifying the Default Value&lt;/h3&gt;

&lt;p&gt;You can specify a default value for a member using a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonDefaultValueAttribute.htm
&#34;&gt;&lt;code&gt;BsonDefaultValueAttribute&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass 
{
    [BsonDefaultValue(&amp;quot;abc&amp;quot;)]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapMember(c =&amp;gt; c.SomeProperty).SetDefaultValue(&amp;quot;abc&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default value and the ignoring of a default value work together. The following will serialize a &lt;code&gt;null&lt;/code&gt; value, but not &lt;code&gt;abc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass 
{
    [BsonIgnoreIfDefault]
    [BsonDefaultValue(&amp;quot;abc&amp;quot;)]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ignoring-a-member-at-runtime:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Ignoring a Member at Runtime&lt;/h3&gt;

&lt;p&gt;Sometimes the decision whether to serialize a member or not is more complicated than just whether the value is &lt;code&gt;null&lt;/code&gt; or equal to the default value. In these cases, you can write a method that determines whether a value should be serialized. Usually the method for member Xyz is named ShouldSerializeXyz. If you follow this naming convention then &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_Serialization_BsonClassMap_1_AutoMap.htm
&#34;&gt;&lt;code&gt;AutoMap&lt;/code&gt;&lt;/a&gt; will automatically detect the method and use it. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Employee 
{
    public ObjectId Id { get; set; }

    [BsonDateTimeOptions(DateOnly = true)]
    public DateTime DateOfBirth { get; set; }

    public bool ShouldSerializeDateOfBirth() 
    {
        return DateOfBirth &amp;gt; new DateTime(1900, 1, 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using code, it can be specified as a lambda expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Employee&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapMember(c =&amp;gt; c.DateOfBirth).SetShouldSerializeMethod(
        obj =&amp;gt; ((Employee) obj).DateOfBirth &amp;gt; new DateTime(1900, 1, 1)
    );
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;specifying-the-serializer:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Specifying the Serializer&lt;/h3&gt;

&lt;p&gt;There are times when a specific serializer needs to be used rather than letting the BSON library choose. This can be done using a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonSerializerAttribute.htm
&#34;&gt;&lt;code&gt;BsonSerializerAttribute&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass 
{
    public ObjectId Id { get; set; }

    [BsonSerializer(typeof(MyCustomStringSerializer))]
    public string X { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapMember(c =&amp;gt; c.X).SetSerializer(new MyCustomStringSerializer());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;serialization-options:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Serialization Options&lt;/h3&gt;

&lt;p&gt;Serialization of some classes can be more finely controlled using serialization options. Whether a class uses serialization options or not, and which ones, depends on the particular class involved. The following sections describe the available serialization option classes and the classes that use them.&lt;/p&gt;

&lt;h4 id=&#34;datetime-serialization-options:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;DateTime Serialization Options&lt;/h4&gt;

&lt;p&gt;Using a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonDateTimeOptionsAttribute.htm
&#34;&gt;&lt;code&gt;BsonDateTimeOptionsAttribute&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass 
{
    [BsonDateTimeOptions(DateOnly = true)]
    public DateTime DateOfBirth { get; set; }

    [BsonDateTimeOptions(Kind = DateTimeKind.Local)]
    public DateTime AppointmentTime { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When done via code, a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Serializers_DateTimeSerializer.htm
&#34;&gt;&lt;code&gt;DateTimeSerializer&lt;/code&gt;&lt;/a&gt; should be set:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapMember(c =&amp;gt; c.DateOfBirth).SetSerializer(new DateTimeSerializer(dateOnly: true));
    cm.MapMember(c =&amp;gt; c.AppointmentTime).SetSerializer(new DateTimeSerializer(DateTimeKind.Local));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we are specifying that the &lt;code&gt;DateOfBirth&lt;/code&gt; value holds a date only (so the TimeOfDay component will be zero). Additionally, because this is a date only, no timezone conversions at all will be performed. The &lt;code&gt;AppointmentTime&lt;/code&gt; value is in local time and will be converted to UTC when it is serialized and converted back to local time when it is deserialized.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
DateTime values in MongoDB are always saved as UTC.
&lt;/div&gt;
&lt;/p&gt;

&lt;h4 id=&#34;dictionary-serialization-options:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Dictionary Serialization Options&lt;/h4&gt;

&lt;p&gt;When serializing dictionaries, there are several alternative ways that the contents of the dictionary can be represented. The &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Options_DictionaryRepresentation.htm
&#34;&gt;&lt;code&gt;DictionaryRepresentation&lt;/code&gt;&lt;/a&gt; enum indicates the supported methods. Using a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonDictionaryOptionsAttribute.htm
&#34;&gt;&lt;code&gt;BsonDictionaryOptionsAttribute&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class C 
{
    public ObjectId Id;
   
    [BsonDictionaryOptions(DictionaryRepresentation.ArrayOfDocuments)]
    public Dictionary&amp;lt;string, int&amp;gt; Values;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When done via code, a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Serializers_DictionaryInterfaceImplementerSerializer.htm
&#34;&gt;&lt;code&gt;DictionaryInterfaceImplementerSerializer&lt;/code&gt;&lt;/a&gt; should be set:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;C&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.MapMember(c =&amp;gt; c.Values).SetSerializer(new DictionaryInterfaceImplementerSerializer&amp;lt;Dictionary&amp;lt;string, int&amp;gt;&amp;gt;(DictionaryRepresentation.ArrayOfDocuments));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The 3 options in the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Options_DictionaryRepresentation.htm
&#34;&gt;&lt;code&gt;DictionaryRepresentation&lt;/code&gt;&lt;/a&gt; enum are as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Document&lt;/code&gt;: A dictionary represented as a Document will be stored as a BsonDocument, and each entry in the dictionary will be represented by a BsonElement with the name equal to the key of the dictionary entry and the value equal to the value of the dictionary entry. This representation can only be used when all the keys in a dictionary are strings that are valid element names.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ArrayOfArrays&lt;/code&gt;: A dictionary represented as an ArrayOfArrays will be stored as a BsonArray of key/value pairs, where each key/value pair is stored as a nested two-element BsonArray where the two elements are the key and the value of the dictionary entry. This representation can be used even when the keys of the dictionary are not strings. This representation is very general and compact, and is the default representation when Document does not apply. One problem with this representation is that it is difficult to write queries against it, which motivated the introduction in the 1.2 version of the driver of the ArrayOfDocuments representation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ArrayOfDocuments&lt;/code&gt;: A dictionary represented as an ArrayOfDocuments will be stored as a BsonArray of key/value pairs, where each key/value pair is stored as a nested two-element BsonDocument of the form { k : key, v : value }. This representation is just as general as the ArrayOfArrays representation, but because the keys and values are tagged with element names it is much easier to write queries against it. For backward compatibility reasons this is not the default representation.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;representation:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Representation&lt;/h3&gt;

&lt;p&gt;For some .NET primitive types you can control what BSON type you want used to represent the value. For example, you can specify whether a char value should be represented as a BSON Int32 or as a one-character BSON String:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass 
{
    [BsonRepresentation(BsonType.Int32)]
    public char RepresentAsInt32 { get; set; }

    [BsonRepresentation(BsonType.String)]
    public char RepresentAsString { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.RepresentAsInt32).SetRepresentation(BsonType.Int32);
    cm.GetMemberMap(c =&amp;gt; c.RepresentAsString).SetRepresentation(BsonType.String);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One case that deserves special mention is representing a string externally as an ObjectId. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Employee 
{
    [BsonRepresentation(BsonType.ObjectId)]
    public string Id { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the serializer will convert the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_ObjectId.htm
&#34;&gt;&lt;code&gt;ObjectId&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;string&lt;/code&gt; when reading data from the database and will convert the &lt;code&gt;string&lt;/code&gt; back to an &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_ObjectId.htm
&#34;&gt;&lt;code&gt;ObjectId&lt;/code&gt;&lt;/a&gt; when writing data to the database (the &lt;code&gt;string&lt;/code&gt; value must be a valid &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_ObjectId.htm
&#34;&gt;&lt;code&gt;ObjectId&lt;/code&gt;&lt;/a&gt;). Typically this is done when you want to keep your domain classes free of any dependencies on the driver. To keep your domain classes free of dependencies on the C# driver you also won’t want to use attributes, so you can accomplish the same thing using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Employee&amp;gt;(cm =&amp;gt; 
{
    cm.AutoMap();
    cm.IdMemberMap.SetRepresentation(BsonType.ObjectId);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;custom-attributes:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Custom Attributes&lt;/h2&gt;

&lt;p&gt;It is possible to implement custom attributes to contribute to the serialization infrastructure. There are 3 interfaces you might want to implement:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_IBsonClassMapAttribute.htm
&#34;&gt;&lt;code&gt;IBsonClassMapAttribute&lt;/code&gt;&lt;/a&gt; is used to contribute to a class map.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_IBsonMemberMapAttribute.htm
&#34;&gt;&lt;code&gt;IBsonMemberMapAttribute&lt;/code&gt;&lt;/a&gt; is used to contribute to a member map.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_IBsonCreatorMapAttribute.htm
&#34;&gt;&lt;code&gt;IBsonCreatorMapAttribute&lt;/code&gt;&lt;/a&gt; is used to contribute to a creator map.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All the provided attributes implement one or more of these interfaces, so they are good examples of how these interfaces function.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Polymorphism</title>
      <link>/mongo-csharp-driver/2.0/reference/bson/mapping/polymorphism/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/reference/bson/mapping/polymorphism/</guid>
      <description>

&lt;h2 id=&#34;polymorphism:33907bf0ce2b8b3d8128c36b8bb881d4&#34;&gt;Polymorphism&lt;/h2&gt;

&lt;p&gt;When you have a class hierarchy and will be serializing instances of varying classes to the same collection you need a way to distinguish one from another. The normal way to do so is to write some kind of special value (called a “discriminator”) in the document along with the rest of the elements that you can later look at to tell them apart. Since there are potentially many ways you could discriminate between actual types, the default serializer uses conventions for discriminators. The default serializer provides two standard discriminators: &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_ScalarDiscriminatorConvention.htm
&#34;&gt;&lt;code&gt;ScalarDiscriminatorConvention&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_HierarchicalDiscriminatorConvention.htm
&#34;&gt;&lt;code&gt;HierarchicalDiscriminatorConvention&lt;/code&gt;&lt;/a&gt;. The default is the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_HierarchicalDiscriminatorConvention.htm
&#34;&gt;&lt;code&gt;HierarchicalDiscriminatorConvention&lt;/code&gt;&lt;/a&gt;, but it behaves just like the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_ScalarDiscriminatorConvention.htm
&#34;&gt;&lt;code&gt;ScalarDiscriminatorConvention&lt;/code&gt;&lt;/a&gt; until certain options are set to trigger its hierarchical behavior.&lt;/p&gt;

&lt;p&gt;The default discriminator conventions both use an element named _t to store the discriminator value in the BSON document. This element will normally be the second element in the BSON document (right after the _id). In the case of the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_ScalarDiscriminatorConvention.htm
&#34;&gt;&lt;code&gt;ScalarDiscriminatorConvention&lt;/code&gt;&lt;/a&gt;, the value of _t will be a single string. In the case of the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_HierarchicalDiscriminatorConvention.htm
&#34;&gt;&lt;code&gt;HierarchicalDiscriminatorConvention&lt;/code&gt;&lt;/a&gt; the value of _t will be an array of discriminator values, one for each level of the class inheritance tree.&lt;/p&gt;

&lt;p&gt;While you will normally be just fine with the default discriminator convention, you might have to write a custom discriminator convention if you must work with data written by another driver or object mapper that uses a different convention for its discriminators.&lt;/p&gt;

&lt;h2 id=&#34;setting-the-discriminator-value:33907bf0ce2b8b3d8128c36b8bb881d4&#34;&gt;Setting the Discriminator Value&lt;/h2&gt;

&lt;p&gt;The default value for the discriminator is the name of the class (without the namespace part). You can specify a different value using attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[BsonDiscriminator(&amp;quot;myclass&amp;quot;)]
public MyClass {
    // fields and properties
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.SetDiscriminator(&amp;quot;myclass&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;specifying-known-types:33907bf0ce2b8b3d8128c36b8bb881d4&#34;&gt;Specifying Known Types&lt;/h2&gt;

&lt;p&gt;When deserializing polymorphic classes, it is important that the serializer know about all the classes in the hierarchy before deserialization begins. If you ever see an error message about an “Unknown discriminator”, it is because the deserializer can’t figure out the class for that discriminator. If you are mapping your classes programmatically simply make sure that all classes in the hierarchy have been mapped before beginning deserialization. When using attributes and &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/#automap:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;automapping&lt;/a&gt;, you will need to inform the serializer about known types (i.e. subclasses) it should create class maps for. Here is an example of how to do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[BsonKnownTypes(typeof(Cat), typeof(Dog)]
public class Animal 
{
}

[BsonKnownTypes(typeof(Lion), typeof(Tiger)]
public class Cat : Animal 
{
}

public class Dog : Animal 
{
}

public class Lion : Cat 
{
}

public class Tiger : Cat 
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonKnownTypesAttribute.htm
&#34;&gt;&lt;code&gt;BsonKnownTypesAttribute&lt;/code&gt;&lt;/a&gt; attribute lets the serializer know what subclasses it might encounter during deserialization, so when &lt;code&gt;Animal&lt;/code&gt; is &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/#automap:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;automapped&lt;/a&gt;, the serializer will also &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/#automap:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;automap&lt;/a&gt; &lt;code&gt;Cat&lt;/code&gt; and &lt;code&gt;Dog&lt;/code&gt;, and recursively, &lt;code&gt;Lion&lt;/code&gt; and &lt;code&gt;Tiger&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Animal&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Cat&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Dog&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Lion&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Tiger&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scalar-and-hierarchical-discriminators:33907bf0ce2b8b3d8128c36b8bb881d4&#34;&gt;Scalar and Hierarchical Discriminators&lt;/h2&gt;

&lt;p&gt;Normally a discriminator is simply the name of the class (although it could be different if you are using a custom discriminator convention or have explicitly specified a discriminator for a class). So a collection containing a mix of different type of Animal documents might look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ _id: ..., _t: &amp;quot;Animal&amp;quot;, ... }
{ _id: ..., _t: &amp;quot;Cat&amp;quot;, ... }
{ _id: ..., _t: &amp;quot;Dog&amp;quot;, ... }
{ _id: ..., _t: &amp;quot;Lion&amp;quot;, ... }
{ _id: ..., _t: &amp;quot;Tiger&amp;quot;, ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes it can be helpful to record a hierarchy of discriminator values, one for each level of the hierarchy. To do this, you must first mark a base class as being the root of a hierarchy, and then the default &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Conventions_HierarchicalDiscriminatorConvention.htm
&#34;&gt;&lt;code&gt;HierarchicalDiscriminatorConvention&lt;/code&gt;&lt;/a&gt; will automatically record discriminators as array values instead.&lt;/p&gt;

&lt;p&gt;To identify &lt;code&gt;Animal&lt;/code&gt; as the root of a hierarchy use the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Attributes_BsonDiscriminatorAttribute.htm
&#34;&gt;&lt;code&gt;BsonDiscriminatorAttribute&lt;/code&gt;&lt;/a&gt; attribute with the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/P_MongoDB_Bson_Serialization_Attributes_BsonDiscriminatorAttribute_RootClass.htm
&#34;&gt;&lt;code&gt;RootClass&lt;/code&gt;&lt;/a&gt; named parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;[BsonDiscriminator(RootClass = true)]
[BsonKnownTypes(typeof(Cat), typeof(Dog)]
public class Animal 
{
}

// the rest of the hierarchy as before
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Animal&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.SetIsRootClass(true);
});
BsonClassMap.RegisterClassMap&amp;lt;Cat&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Dog&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Lion&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Tiger&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that you have identified Animal as a root class, the discriminator values will look a little bit different:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ _id: ..., _t: &amp;quot;Animal&amp;quot;, ... }
{ _id: ..., _t: [&amp;quot;Animal&amp;quot;, &amp;quot;Cat&amp;quot;], ... }
{ _id: ..., _t: [&amp;quot;Animal&amp;quot;, &amp;quot;Dog&amp;quot;], ... }
{ _id: ..., _t: [&amp;quot;Animal&amp;quot;, &amp;quot;Cat&amp;quot;, &amp;quot;Lion&amp;quot;], ... }
{ _id: ..., _t: [&amp;quot;Animal&amp;quot;, &amp;quot;Cat&amp;quot;, &amp;quot;Tiger&amp;quot;], ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main reason you might choose to use hierarchical discriminators is because it makes it possibly to query for all instances of any class in the hierarchy. For example, to read all the &lt;code&gt;Cat&lt;/code&gt; documents we can use the following filter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var filter = new BsonDocument(&amp;quot;_t&amp;quot;, &amp;quot;Cat&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Handling Schema Changes</title>
      <link>/mongo-csharp-driver/2.0/reference/bson/mapping/schema_changes/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/reference/bson/mapping/schema_changes/</guid>
      <description>

&lt;h2 id=&#34;handling-schema-changes:3d4bdfa14ec4eda85bd3b08b8c601569&#34;&gt;Handling Schema Changes&lt;/h2&gt;

&lt;p&gt;Just because MongoDB is schema-less does not mean that your code can handle a schema-less document. Most likely, if you are using a statically typed language like C# or VB.NET, then your code is not flexible and needs to be mapped to a known schema.&lt;/p&gt;

&lt;p&gt;There are a number of different ways that a schema can change from one version of your application to the next.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#a-member-has-been-added:3d4bdfa14ec4eda85bd3b08b8c601569&#34;&gt;A new member is added&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#a-member-has-been-removed:3d4bdfa14ec4eda85bd3b08b8c601569&#34;&gt;A member is removed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#a-member-has-been-renamed:3d4bdfa14ec4eda85bd3b08b8c601569&#34;&gt;A member is renamed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-type-of-a-member-is-changed:3d4bdfa14ec4eda85bd3b08b8c601569&#34;&gt;The type of a member is changed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-representation-of-a-member-is-changed:3d4bdfa14ec4eda85bd3b08b8c601569&#34;&gt;The representation of a member is changed&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;How you handle these is up to you. There are two different strategies:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Write an upgrade script.&lt;/li&gt;
&lt;li&gt;Incrementally update your documents as they are used.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The easiest strategy is to write an upgrade script. There is effectively no difference to this method between a relational database (SQL Server, Oracle) and MongoDB. Identify the documents that need to be changed and update them.&lt;/p&gt;

&lt;p&gt;Alternatively, and not supportable in most relational databases, is the incremental upgrade. The idea is that your documents get updated as they are used. Documents that are never used never get updated. Because of this, there are some definite pitfalls you will need to be aware of.&lt;/p&gt;

&lt;p&gt;First, queries against a schema where half the documents are version 1 and half the documents are version 2 could go awry. For instance, if you rename an element, then your query will need to test both the old element name and the new element name to get all the results.&lt;/p&gt;

&lt;p&gt;Second, any incremental upgrade code must stay in the code-base until all the documents have been upgraded. For instance, if there have been 3 versions of a document, [1, 2, and 3] and we remove the upgrade code from version 1 to version 2, any documents that still exist as version 1 are un-upgradeable.&lt;/p&gt;

&lt;h2 id=&#34;a-member-has-been-added:3d4bdfa14ec4eda85bd3b08b8c601569&#34;&gt;A Member Has Been Added&lt;/h2&gt;

&lt;p&gt;When a new member is added to an entity, there is nothing that needs to be done other than restarting the application if you are using the auto mapping features. If not, then you will manually need to map the member in the same way all the other members are getting mapped.&lt;/p&gt;

&lt;p&gt;Existing documents will not have this element and it will show up in your class with its default value. You can, of course, specify a default value.&lt;/p&gt;

&lt;h2 id=&#34;a-member-has-been-removed:3d4bdfa14ec4eda85bd3b08b8c601569&#34;&gt;A Member Has Been Removed&lt;/h2&gt;

&lt;p&gt;When a member has been removed from am entity, it will continue to exist in the documents. The serializer will throw an exception when this element is seen because it doesn’t know what to do with it. See the sections on &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/#supporting-extra-elements:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;supporting extra elements&lt;/a&gt; and &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/#ignoring-extra-elements:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;ignoring extra elements&lt;/a&gt; for information on how to deal with this.&lt;/p&gt;

&lt;h2 id=&#34;a-member-has-been-renamed:3d4bdfa14ec4eda85bd3b08b8c601569&#34;&gt;A Member Has Been Renamed&lt;/h2&gt;

&lt;p&gt;When a member has been renamed, it will exist in old documents with the old name and in new documents with the new name. The way to handle incremental upgrades for this rename would be to implement an &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/#supporting-extra-elements:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;ExtraElements&lt;/a&gt; member in conjunction with &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/#issuportinitialize:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;ISupportInitialize&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For example, let’s say that a class used to have a &lt;code&gt;Name&lt;/code&gt; property which has now been split into a &lt;code&gt;FirstName&lt;/code&gt; and a &lt;code&gt;LastName&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class MyClass : ISupportInitialize 
{
    public string FirstName { get; set; }
    public string LastName { get; set; }

    [BsonExtraElements]
    public IDictionary&amp;lt;string, object&amp;gt; ExtraElements { get; set; }

    void ISupportInitialize.BeginInit() 
    {
        // nothing to do at beginning
    }

    void ISupportInitialize.EndInit() 
    {
        object nameValue;
        if (!ExtraElements.TryGetValue(&amp;quot;Name&amp;quot;, out nameValue)) {
            return;
        }

        var name = (string)nameValue;

        // remove the Name element so that it doesn&#39;t get persisted back to the database
        ExtraElements.Remove(&amp;quot;Name&amp;quot;);

        // assuming all names are &amp;quot;First Last&amp;quot;
        var nameParts = name.Split(&#39; &#39;);

        FirstName = nameParts[0];
        LastName = nameParts[1];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-type-of-a-member-is-changed:3d4bdfa14ec4eda85bd3b08b8c601569&#34;&gt;The Type of a Member Is Changed&lt;/h2&gt;

&lt;p&gt;If the .NET type is compatible with the old type (an integer is changed to a double), then everything will continue to work. Otherwise, a custom serializer or a migration script will be required.&lt;/p&gt;

&lt;h2 id=&#34;the-representation-of-a-member-is-changed:3d4bdfa14ec4eda85bd3b08b8c601569&#34;&gt;The Representation of a Member Is Changed&lt;/h2&gt;

&lt;p&gt;If the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/#representation:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;representation of a member&lt;/a&gt; is changed and the representations are compatible, then everything will continue to work. Otherwise, a custom serializer or a migration script will be required.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Serialization</title>
      <link>/mongo-csharp-driver/2.0/reference/bson/serialization/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/reference/bson/serialization/</guid>
      <description>

&lt;h2 id=&#34;serialization:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;Serialization&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/bson/&#34;&gt;Reading and Writing BSON/JSON&lt;/a&gt; demonstrates how to manually read and write BSON and JSON. However, using the serialization classes make this process much easier.&lt;/p&gt;

&lt;p&gt;Serialization is the process of mapping an object to and from a BSON document. The architecture is extensible with numerous hooks to allow you to take more control of the process when necessary.&lt;/p&gt;

&lt;h2 id=&#34;serializer-registry:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;Serializer Registry&lt;/h2&gt;

&lt;p&gt;The serializer registry contains all the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_IBsonSerializer.htm
&#34;&gt;&lt;code&gt;IBsonSerializers&lt;/code&gt;&lt;/a&gt; that have been registered. It can be accessed via the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/P_MongoDB_Bson_BsonSerializer_SerializerRegistry.htm
&#34;&gt;&lt;code&gt;SerializerRegistry&lt;/code&gt;&lt;/a&gt; property of the static class &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/MongoDB_Bson_BsonSerializer.htm
&#34;&gt;&lt;code&gt;BsonSerializer&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
This is a global registry. Currently, you cannot use multiple registries in a single application.
&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;serialization-provider:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;Serialization Provider&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;#serializer-registry:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;serializer registry&lt;/a&gt; is powered by a list of &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_IBsonSerializationProvider.htm
&#34;&gt;&lt;code&gt;IBsonSerializationProvider&lt;/code&gt;&lt;/a&gt;. A serialization provider allows you to provide serializers on demand. The provider should be registered as soon as possible to ensure that the serializers provided are used. You can delegate handling of any types your custom provider isn&amp;rsquo;t prepared to handle by returning null from &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_Serialization_IBsonSerializationProvider_GetSerializer.htm
&#34;&gt;&lt;code&gt;GetSerializer&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;implementation:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;To implement an &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_IBsonSerializationProvider.htm
&#34;&gt;&lt;code&gt;IBsonSerializationProvider&lt;/code&gt;&lt;/a&gt;, create a class that implements the interface and register it using the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_BsonSerializer_RegisterSerializationProvider.htm
&#34;&gt;&lt;code&gt;RegisterSerializationProvider&lt;/code&gt;&lt;/a&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;class MyProvider : IBsonSerializationProvider
{
    public IBsonSerializer GetSerializer(Type type)
    {
        if (type == typeof(int))
        {
            return new MyInt32Serializer();
        }        

        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above, we have a custom implemention of a serializer for an &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.int32.aspx&#34;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;. If the type being requested is for an &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.int32.aspx&#34;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, we return our serializer. Otherwise, we return null to let the next &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_IBsonSerializationProvider.htm
&#34;&gt;&lt;code&gt;IBsonSerializationProvider&lt;/code&gt;&lt;/a&gt; in line handle the request.&lt;/p&gt;

&lt;h2 id=&#34;serializers:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;Serializers&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_IBsonSerializer.htm
&#34;&gt;&lt;code&gt;IBsonSerializer&lt;/code&gt;&lt;/a&gt; is the main interface that is used to handle translating complex types. There are many serializers already built for handling primitive types, collection types, and &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/bson/mapping/&#34;&gt;custom classes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For example, to read a file containing the JSON &lt;code&gt;{ a: 1, b: [{ c: 1 }] }&lt;/code&gt; into a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_BsonDocument.htm
&#34;&gt;&lt;code&gt;BsonDocument&lt;/code&gt;&lt;/a&gt;, use the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Serializers_BsonDocumentSerializer.htm
&#34;&gt;&lt;code&gt;BsonDocumentSerializer&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var jsonString = &amp;quot;{ a: 1, b: [{ c: 1 }] }&amp;quot;;
using (var reader = new JsonReader(jsonString))
{
    var context = BsonDeserializationContext.CreateRoot(reader);
    BsonDocument doc = BsonDocumentSerializer.Instance.Deserialize(context);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implementation-1:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;div class=&#34;admonition warning&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
Writing custom serializers to handle both normal cases and edge cases can be very tricky.
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;To implement a custom &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_IBsonSerializer.htm
&#34;&gt;&lt;code&gt;IBsonSerializer&lt;/code&gt;&lt;/a&gt;, it is best to inherit from &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Serializers_SerializerBase_1.htm
&#34;&gt;&lt;code&gt;SerializerBase&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and override the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_Serialization_Serializers_SerializerBase_1_Deserialize.htm
&#34;&gt;&lt;code&gt;Deserializer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/M_MongoDB_Bson_Serialization_Serializers_SerializerBase_1_Serialize.htm
&#34;&gt;&lt;code&gt;Serialize&lt;/code&gt;&lt;/a&gt; methods.&lt;/p&gt;

&lt;p&gt;For example, it implement a serializer that reads an &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.int32.aspx&#34;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;class MyInt32Serializer : SerializerBase&amp;lt;int&amp;gt;
{
    public override int Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args)
    {
        return context.Reader.ReadInt32();
    }

    public override void Serialize(BsonSerializationContext context, BsonSerializationArgs args, int value)
    {
        context.Writer.WriteInt32(value);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is overly simplistic. There are other factors that would need to be taken into account such as what happens when the actual BSON type is an &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.int64.aspx&#34;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. In this case, the below implementation is much better:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;class MyInt32Serializer : SerializerBase&amp;lt;int&amp;gt;
{
    public override int Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args)
    {
        var type = context.Reader.GetCurrentBsonType();
        switch (type)
        {
            case BsonType.Int32:
                return context.Reader.ReadInt32();
            case BsonType.Int64:
                return Convert.ToInt32(context.Reader.ReadInt64());
            case BsonType.Double:
                return Convert.ToInt32(context.Reader.ReadDouble());
            case BsonType.String:
                return int.Parse(context.Reader.ReadString());
            default:
                var message = string.Format(&amp;quot;Cannot convert a {0} to an Int32.&amp;quot;, type);
                throw new NotSupportedException(message);
        }
    }

    public override void Serialize(BsonSerializationContext context, BsonSerializationArgs args, int value)
    {
        context.Writer.WriteInt32(value);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we are testing the current BsonType while reading and making decisions. Since some of these conversions could result in an overflow or truncation, exceptions may still be thrown.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
&lt;p&gt;The built-in &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_Serializers_Int32Serializer.htm&#34;&gt;&lt;code&gt;Int32Serializer&lt;/code&gt;&lt;/a&gt; accounts for this as well as other such items.&lt;/p&gt;

&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;You can register your serializer using the &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_BsonSerializer_RegisterSerializer.htm
&#34;&gt;&lt;code&gt;RegisterSerializer&lt;/code&gt;&lt;/a&gt; or implement a &lt;a href=&#34;#serialization-provider:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;serialization provider&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;opt-in-interfaces:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;Opt-in Interfaces&lt;/h3&gt;

&lt;p&gt;There are some opt-in interfaces that allow the driver to utilize your custom serializer in special ways. You should evaluate these interfaces and decide whether your serializer should implement them.&lt;/p&gt;

&lt;h4 id=&#34;ibsonidprovider:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;IBsonIdProvider&lt;/h4&gt;

&lt;p&gt;If your class is used as a root document, you should implement the IBsonIdProvider interface in order for &amp;ldquo;Inserting&amp;rdquo; the document to function best, especially if the class your serializer is for uses an Id type other than &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_ObjectId.htm
&#34;&gt;&lt;code&gt;ObjectId&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;ibsondocumentserializer:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;IBsonDocumentSerializer&lt;/h4&gt;

&lt;p&gt;In order to enable the driver to properly construct type-safe queries using a custom serializer, it needs access to member information. If your custom serializer is for a class, then you should implement &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_IBsonDocumentSerializer.htm
&#34;&gt;&lt;code&gt;IBsonDocumentSerializer&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;class MyClass
{
    public ObjectId Id { get; set; }

    public string FirstName { get; set; }

    public string LastName { get; set; }
}

class MyClassSerializer : SerializerBase&amp;lt;MyClass&amp;gt;, IBsonDocumentSerializer
{
    // implement Serialize and Deserialize

    public bool TryGetMemberSerializationInfo(string memberName, out BsonSerializationInfo serializationInfo)
    {
        switch (memberName)
        {
            case &amp;quot;Id&amp;quot;:
                serializationInfo = new BsonSerializationInfo(&amp;quot;_id&amp;quot;, new ObjectIdSerializer(), typeof(ObjectId));
                return true;
            case &amp;quot;FirstName&amp;quot;:
                serializationInfo = new BsonSerializationInfo(&amp;quot;fn&amp;quot;, new StringSerializer(), typeof(string));
                return true;
            case &amp;quot;LastName&amp;quot;:
                serializationInfo = new BsonSerializationInfo(&amp;quot;ln&amp;quot;, new StringSerializer(), typeof(string));
                return true;
            default:
                serializationInfo = null;
                return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above, we are providing information about the members of our class based on the member name. This enables the driver to, for instance, translate the below lambda expression into &lt;code&gt;{ fn: &#39;Jack&#39; }&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;Find(x =&amp;gt; x.FirstName == &amp;quot;Jack&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;ibsonarrayserializer:9f7e4d8b174e71a2ac5d4d28c9548f5c&#34;&gt;IBsonArraySerializer&lt;/h4&gt;

&lt;p&gt;In the same way, if you have written a custom collection serializer, you should implement &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Bson_Serialization_IBsonArraySerializer.htm
&#34;&gt;&lt;code&gt;IBsonArraySerializer&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Authentication</title>
      <link>/mongo-csharp-driver/2.0/reference/driver/authentication/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/reference/driver/authentication/</guid>
      <description>

&lt;h2 id=&#34;authentication:6b57b661b9236f856cd4f0afa1bed671&#34;&gt;Authentication&lt;/h2&gt;

&lt;p&gt;The .NET driver supports all &lt;a href=&#34;http://docs.mongodb.org/manual/core/authentication/
&#34;&gt;MongoDB authentication mechanisms&lt;/a&gt; including those in the &lt;a href=&#34;http://docs.mongodb.org/manual/administration/install-enterprise/
&#34;&gt;Enterprise Edition&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Authentication credentials are created by the application as instances of &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_MongoCredential.htm
&#34;&gt;&lt;code&gt;MongoCredential&lt;/code&gt;&lt;/a&gt; which includes static factory methods for each of the supported authentication mechanisms. A list of these instances must be passed to the driver using the &lt;code&gt;MongoClient&lt;/code&gt; constructor that takes a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_MongoClientSettings.htm
&#34;&gt;&lt;code&gt;MongoClientSettings&lt;/code&gt;&lt;/a&gt;. When only one credential is necessary, it is possible to specify via the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/getting_started/connecting/#connection-string:d67a243cdf521fafcb45cf3f560d3e12&#34;&gt;connection string&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;default:6b57b661b9236f856cd4f0afa1bed671&#34;&gt;Default&lt;/h3&gt;

&lt;p&gt;MongoDB 3.0 changed the default authentication mechanism from &lt;a href=&#34;http://docs.mongodb.org/manual/core/authentication/#mongodb-cr-authentication&#34;&gt;MONGODB-CR&lt;/a&gt; to &lt;a href=&#34;http://docs.mongodb.org/manual/core/authentication/#scram-sha-1-authentication&#34;&gt;SCRAM-SHA-1&lt;/a&gt;. To create a credential that will authenticate properly regardless of server version, create a credential using the following static factory method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var credential = MongoCredential.CreateCredential(databaseName, username, password);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via the connection string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://username:password@myserver/databaseName
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the recommended approach as it will make upgrading from MongoDB 2.6 to MongoDB 3.0 seamless, even after &lt;a href=&#34;http://docs.mongodb.org/manual/release-notes/3.0-scram/#upgrade-mongodb-cr-to-scram&#34;&gt;upgrading the authentication schema&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
The databaseName part of the connection string indicates which database the credentials are located in. See the &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/getting_started/connecting/#connection-string:d67a243cdf521fafcb45cf3f560d3e12&#34;&gt;connection string section&lt;/a&gt; for more information on connection strings.
&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;x-509-authentication:6b57b661b9236f856cd4f0afa1bed671&#34;&gt;x.509 Authentication&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;http://docs.mongodb.org/manual/core/authentication/#x-509-certificate-authentication&#34;&gt;x.509&lt;/a&gt; mechanism authenticates a user whose name is derived from the distinguished subject name of the x.509 certificate presented by the driver during SSL negotiation. This authentication method requires the use of SSL connections with certificate validation and is available in MongoDB 2.6 and newer. To create a credential of this type, use the following static factory method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var credential = MongoCredential.CreateX509Credential(username);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via the connection string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://username@myserver/?authMechanism=MONGODB-X509
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even when using the connection string to provide the credential, the certificate must still be provided via code. This certificate can be pulled out of the trust stores on the box, or from a file. However, to be used with client authentication, the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.security.cryptography.x509certificates.x509certificate.aspx&#34;&gt;X509Certificate&lt;/a&gt; provided to the driver must contain the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.security.cryptography.x509certificates.x509certificate2.privatekey.aspx&#34;&gt;PrivateKey&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var cert = new X509Certificate2(&amp;quot;client.pfx&amp;quot;, &amp;quot;mySuperSecretPassword&amp;quot;);

var settings = new MongoClientSettings
{
    Credentials = new[] 
    {
        MongoCredential.CreateMongoX509Credential(&amp;quot;CN=client,OU=user,O=organization,L=Some City,ST=Some State,C=Some Country&amp;quot;)
    },
    SslSettings = new SslSettings
    {
        ClientCertificates = new[] { cert },
    },
    UseSsl = true
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;gssapi-kerberos:6b57b661b9236f856cd4f0afa1bed671&#34;&gt;GSSAPI/Kerberos&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mongodb.com/products/mongodb-enterprise&#34;&gt;MongoDB Enterprise&lt;/a&gt; supports authentication using &lt;a href=&#34;http://docs.mongodb.org/manual/core/authentication/#kerberos-authentication&#34;&gt;Kerberos/GSSAPI&lt;/a&gt;. To create a Kerberos/GSSAPI credential, use the following method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var credential = MongoCredential.CreateGssapiCredential(username, password);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via the connection string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://username%40REALM.com:password@myserver/?authMechanism=GSSAPI
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
Note that the username will need to have a REALM associated with it. When used in a connection string, &lt;code&gt;%40&lt;/code&gt; is the escape character for the &lt;code&gt;@&lt;/code&gt; symbol.
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;If the process owner running your application is the same as the user needing authentication, you can omit the password:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var credential = MongoCredential.CreateGssapiCredential(username);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via the connection string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://username%40REALM.com@myserver/?authMechanism=GSSAPI
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depending on the kerberos setup, it may be required to specify some additional properties. These may be specified in the connection string or via code.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;CANONICALIZE_HOST_NAME&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Uses the DNS server to retrieve the fully qualified domain name (FQDN) of the host.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;credential = credential.WithMechanismProperty(&amp;quot;CANONICALIZE_HOST_NAME&amp;quot;, &amp;quot;true&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via the connection string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://username@myserver/?authMechanism=GSSAPI&amp;amp;authMechanismProperties=CANONICALIZE_HOSTNAME:true
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;REALM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is used when the user&amp;rsquo;s realm is different from the service&amp;rsquo;s realm.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;credential = credential.WithMechanismProperty(&amp;quot;REALM&amp;quot;, &amp;quot;otherrealm&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via the connection string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://username%40REALM.com@myserver/?authMechanism=GSSAPI&amp;amp;authMechanismProperties=REALM:otherrealm
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;SERVICE_NAME&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is used when the service&amp;rsquo;s name is different that the default &lt;code&gt;mongodb&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;credential = credential.WithMechanismProperty(&amp;quot;SERVICE_NAME&amp;quot;, &amp;quot;othername&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via the connection string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://username%40REALM.com@myserver/?authMechanism=GSSAPI&amp;amp;authMechanismProperties=SERVICE_NAME:othername
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition, it is possible to use multiple authentication mechanism properties either via code or in the connection string. In code, call &lt;code&gt;WithMechanismProperty&lt;/code&gt; multiple times. In the connection string, separate the entries with a &lt;code&gt;,&lt;/code&gt; (comma).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://username%40REALM.com@myserver/?authMechanism=GSSAPI&amp;amp;authMechanismProperties=SERVICE_NAME:othername,REALM:otherrealm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ldap-plain:6b57b661b9236f856cd4f0afa1bed671&#34;&gt;LDAP (PLAIN)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mongodb.com/products/mongodb-enterprise&#34;&gt;MongoDB Enterprise&lt;/a&gt; supports proxy authentication through a Lightweight Directory Access Protocol (LDAP) service. To create a credential of type LDAP use the following static factory method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;var credential = MongoCredential.CreatePlainCredential(&amp;quot;$external&amp;quot;, username, password);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via the connection string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://username:password@myserver/?authSource=$external&amp;amp;authMechanism=PLAIN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
Note that the method refers to the plain authentication mechanism instead of LDAP because technically the driver is authenticating via the PLAIN SASL mechanism. This means that your credentials are in plain text on the wire. Therefore, PLAIN should only be used in conjunction with SSL.
&lt;/div&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Connecting</title>
      <link>/mongo-csharp-driver/2.0/reference/driver/connecting/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/2.0/reference/driver/connecting/</guid>
      <description>

&lt;h2 id=&#34;connection-string:d67a243cdf521fafcb45cf3f560d3e12&#34;&gt;Connection String&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;http://docs.mongodb.org/manual/reference/connection-string/&#34;&gt;connection string&lt;/a&gt; is the simplest way to connect to one or more MongoDB servers. A connection string mostly follows &lt;a href=&#34;http://tools.ietf.org/html/rfc3986&#34;&gt;RFC 3986&lt;/a&gt; with the exception of the domain name. For MongoDB, it is possible to list multiple domain names separated by a comma. Below are some example connection strings&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For a standalone mongod, mongos, or a direct connection to a member of a replica set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://host:27017
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To connect to multiple mongos or a replica set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://host1:27017,host2:27017
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/driver/authentication/&#34;&gt;authentication guide&lt;/a&gt; contains information on how to provide credentials.&lt;/p&gt;

&lt;h3 id=&#34;the-database-component:d67a243cdf521fafcb45cf3f560d3e12&#34;&gt;The Database Component&lt;/h3&gt;

&lt;p&gt;The database component is optional and is used to indicate which database to authenticate against. When the database component is not provided, the &amp;ldquo;admin&amp;rdquo; database is used.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://host:27017/mydb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above, the database by the name of &amp;ldquo;mydb&amp;rdquo; is where the credentials are stored for the application.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;admonition note&#34;&gt;
&lt;h5 class=&#34;admonition-title&#34;&gt;Note&lt;/h5&gt;
Some drivers utilize the database component to indicate which database to work with by default. The .NET driver, while it parses the database component, does not use the database component for anything other than authentication.
&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;options:d67a243cdf521fafcb45cf3f560d3e12&#34;&gt;Options&lt;/h3&gt;

&lt;p&gt;Many options can be provided via the connection string. The ones that cannot may be provided in a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_MongoClientSettings.htm
&#34;&gt;&lt;code&gt;MongoClientSettings&lt;/code&gt;&lt;/a&gt; object. To provide an option on the connection string, append a &lt;code&gt;?&lt;/code&gt; and separate multiple options by an &lt;code&gt;&amp;amp;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodb://host:27017/?replicaSet=rs0&amp;amp;uuidRepresentation=standard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above connection string sets the &amp;ldquo;replicaSet&amp;rdquo; value to &amp;ldquo;rs0&amp;rdquo; and the &amp;ldquo;uuidRepresentation&amp;rdquo; to &amp;ldquo;standard&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;For a comprehensive list of the available options, see the MongoDB &lt;a href=&#34;http://docs.mongodb.org/manual/reference/connection-string/&#34;&gt;connection string&lt;/a&gt; documentation.&lt;/p&gt;

&lt;h2 id=&#34;mongoclient:d67a243cdf521fafcb45cf3f560d3e12&#34;&gt;MongoClient&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_MongoClient.htm
&#34;&gt;&lt;code&gt;MongoClient&lt;/code&gt;&lt;/a&gt; object will be the root object. It is all that is needed to handle connecting to servers, monitoring servers, and performing operations against those servers. Without any arguments, constructing a &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_MongoClient.htm
&#34;&gt;&lt;code&gt;MongoClient&lt;/code&gt;&lt;/a&gt; instance will connect to &amp;ldquo;localhost&amp;rdquo; port 27017.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var client = new MongoClient();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, a connection string may be provided:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var client = new MongoClient(&amp;quot;mongodb://host:27017,host2:27017/?replicaSet=rs0&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_MongoClientSettings.htm
&#34;&gt;&lt;code&gt;MongoClientSettings&lt;/code&gt;&lt;/a&gt; provides an in code way to set the same options.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var settings = new MongoClientSettings { ReplicaSetName = &amp;quot;rs0&amp;quot; };
var client = new MongoClient(settings);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;monitoring:d67a243cdf521fafcb45cf3f560d3e12&#34;&gt;Monitoring&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_MongoClient.htm
&#34;&gt;&lt;code&gt;MongoClient&lt;/code&gt;&lt;/a&gt; utilizes an &lt;a href=&#34;http://api.mongodb.org/csharp/2.0/html/T_MongoDB_Driver_Core_Clusters_ICluster.htm
&#34;&gt;ICluster&lt;/a&gt; from &lt;a href=&#34;/mongo-csharp-driver/2.0/mongo-csharp-driver/2.0/reference/driver_core/&#34;&gt;MongoDB.Driver.Core&lt;/a&gt; which handles monitoring the cluster.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>